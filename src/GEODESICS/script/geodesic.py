import openmesh as om
import igl
import polyscope as ps
import numpy as np
import random
import sys

def solveEdgeIntersection(d, v, w, P, B, C):
    """
    Solve the intersection between a line defined by a (point, vector) and a line defined by two points

    This function computes the intersection point of a line starting at point P
    and aligned with vector d, with the line defined by points B and C.
    It returns the solution vector (see below) and the intersection point.

    Parameters:
    d (numpy.ndarray): Direction vector of the line.
    v (numpy.ndarray): Vector from point B to point C.
    w (numpy.ndarray): Vector from point C to point A.
    P (numpy.ndarray): Starting point of the line.
    B (numpy.ndarray): First endpoint of the edge.
    C (numpy.ndarray): Second endpoint of the edge.

    Returns:
    tuple: A tuple containing:
        - sol (numpy.ndarray): Solution vector.
          such that Q = P + sol[0] * d = (1-sol[1])*B + sol[1]*C
          i.e. sol[0] encodes the intersection point along the line starting at P in the direction d
          and  sol[1] encodes the intersection point in the line generated by points B and C
        - Q1 (numpy.ndarray): Intersection point.
    """
    m11 = np.dot( d, -v)
    m12 = np.dot( v, v)
    m21 = np.dot( d, +w)
    m22 = np.dot( -v, +w)
    rhs1 = np.dot( B-P, -v)
    rhs2 = np.dot( B-P, +w)
    m = np.array([ [m11,m12],[m21,m22]])
    rhs = np.array([rhs1, rhs2]).transpose()
    sol = np.linalg.solve( m, rhs)
    print(sol)
    print(np.allclose( m@sol, rhs))
    Q1 = P + sol[0] * d
    Q2 = (1. - sol[1]) * B + sol[1] * C
    print(np.allclose( Q1, Q2))
    return sol, Q1


def findNextPoint(mesh, heh, lmbda, theta, P):
    """
    Find the next point on the geodesic curve on a triangular mesh.

    This function computes the next point on a geodesic curve starting from a given point P on a triangular mesh.
    It determines the next face and edge along the geodesic, and calculates the new point, angle, and barycentric coordinate.

    Parameters:
    mesh (openmesh.TriMesh): The triangular mesh.
    heh (openmesh.HalfedgeHandle): The current halfedge handle.
    lmbda (float): The barycentric coordinate along the current edge.
    theta (float): The angle between the current edge and the geodesic direction.
    P (numpy.ndarray): The current point on the geodesic curve.

    Returns:
    tuple: A tuple containing:
        - nHeh (openmesh.HalfedgeHandle): The next halfedge handle.
        - nLmbda (float): The barycentric coordinate along the next edge.
        - nTheta (float): The new angle between the next edge and the geodesic direction.
        - nP (numpy.ndarray): The next point on the geodesic curve.
    """
    print(f"=========== start of {findNextPoint.__name__}")
    print(f"current face = {mesh.face_handle(heh).idx()}")
    print(f"current edge = {heh.idx()}")
    print(f"current lmbda = {lmbda}")
    print(f"current theta = {theta}")

    if theta > np.pi:
        print(f"cas super chelou ou l'angle theta est > pi: {theta}")
        heh = mesh.opposite_halfedge_handle(heh)
        theta = theta - np.pi
        lmbda = 1. - lmbda

    he1 = heh
    he2 = mesh.next_halfedge_handle(he1)
    he3 = mesh.next_halfedge_handle(he2)
    Ah = mesh.from_vertex_handle(he1)
    Bh = mesh.from_vertex_handle(he2)
    Ch = mesh.from_vertex_handle(he3)

    A = mesh.point(Ah) # vertices of the triangle
    B = mesh.point(Bh)
    C = mesh.point(Ch)

    u = B - A # edges of the triangle
    v = C - B
    w = A - C

    n = np.cross( v, w) # normal of the triangle
    uT = np.cross( n, u) # normal to the vector u in the plane of the triangle
    print(f"check that uT points towards the interior of the triangle: {np.dot( uT, C-A) >= 0.}")
    d = np.cos(theta) * u / np.linalg.norm(u) + np.sin(theta) * uT / np.linalg.norm( uT) # vector along the geodesic

    oP = (1.0 - lmbda) * A + lmbda * B
    assert np.allclose( P, oP)

    # search the intersection between the line starting at P in the direction of the geodesic
    # and the edge B, C
    # small "n" before a letter means "next". nP: next point P, nFh: next face handle...
    sol, nP = solveEdgeIntersection( d, v, w, P, B, C)
    print(f"solution of intersection by first segment [B C]: {sol}")

    if sol[1] < 0. or sol[1] > 1.:
        # the computed intersection is not inside segment [B,C]
        # => interesect with line [A,C], and check that this intersection is inside the segnent [A,C]
        print(f"wrong edge intersection: sol[1]={sol[1]}")
        if sol[0] < 0.:
            print("pointing outside")
        else:
            print("pointing inside")
        # search the intersection between the line starting at P in the direction of the geodesic
        # and the edge A, C
        sol, nP = solveEdgeIntersection( d, -w, +v, P, A, C)

        # assert(sol[0]>=0.), "after correction new intersection points inside current triangle"

        print(f"corrected: sol[0] = {sol[0]}")
        print(f"           sol[1] = {sol[1]}")
        # nHehOpp = mesh.opposite_halfedge_handle( he3)
        nHehOpp = he3
        nLmbda = sol[1]
        nU = w
    else:
        if sol[0]<=0.:
            print(f"fatal error: intersection inside segment BC and outside triangle: sol={sol}")
            sys.exit(1)
        print("intersection on next geodesic point")
        nHehOpp = he2
        nLmbda = 1 - sol[1]
        nU = v

    assert sol[1]>=0 and sol[1]<=1., "new intersection should be inside segment"
    # assert sol[0]>=0, "new intersection should point inside current triangle"

    # here the next point on the geodesic is inside the edge nHehOpp, with barycentric coordinate sol[1]
    # inverse the edge orientation and extract the next face along the geodesic
    nHeh = mesh.opposite_halfedge_handle(nHehOpp)

    nTheta = np.pi - np.arccos( np.dot( d/np.linalg.norm(d), nU/np.linalg.norm(nU)))
    print(f"nTheta = {nTheta}")
                                   
    # ps.register_curve_network( "myTriangle", np.array([A, B, C, A]), edges="line", radius=0.00075)
    # ps.register_curve_network( "myGeodesic", np.array([P, Q]), edges="line", radius=0.00075)

    return nHeh, nLmbda, nTheta, nP

def initGeodesic(mesh, v, f, facesWithPoints):
    """
    Initialize a geodesic curve on a triangular mesh.

    This function selects a starting point and direction for a geodesic curve on a triangular mesh.
    It randomly selects a face, an edge within that face, and a point along that edge to start the geodesic.
    It also randomly selects an initial direction for the geodesic curve.

    Parameters:
    mesh (openmesh.TriMesh): The triangular mesh.
    v (numpy.ndarray): Array of vertex positions.
    f (numpy.ndarray): Array of face indices.
    facesWithPoints (set): Set of face indices that already have starting points.

    Returns:
    tuple: A tuple containing:
        - fh (openmesh.FaceHandle): The starting face handle.
        - heh (openmesh.HalfedgeHandle): The starting halfedge handle.
        - lmbda (float): The barycentric coordinate along the starting edge (between 0 and 1).
        - theta (float): The initial angle between the starting edge and the geodesic direction (in radians).
        - P (numpy.ndarray): The starting point of the geodesic curve.
    """
    # Get all face handles
    # if True:
    if "-farthest" not in sys.argv or facesWithPoints == set():
        face_handles = list(mesh.faces())
        if not face_handles:
            raise ValueError("Mesh has no faces.")
        # Pick a random face
        fh = random.choice(face_handles)
        # fhIdx = 10
        # fh = mesh.face_handle(fhIdx)
    else:
        vs = np.array([], dtype=int)
        fs = np.array(list(facesWithPoints), dtype=int)
        vt = np.array([], dtype=int)
        ft = np.array(np.arange(mesh.n_faces()))
        d = igl.exact_geodesic(v, f, vs, fs, vt, ft)
        faceIndex = np.argmax(d)
        print(f"CHOOSING NEXT FACE WITH INDEX {faceIndex}")
        fh = om.FaceHandle(faceIndex)

    print(f"start face index = {fh.idx()}")

    # Get all halfedges around this face
    hehs = list(mesh.fh(fh))  # face -> halfedges

    # Pick a random halfedge (which represents an edge)
    heh = random.choice(hehs)
    print(f"start half edge = {heh}")
    # heh = hehs[0]
    from_vh = mesh.from_vertex_handle(heh)
    to_vh = mesh.to_vertex_handle(heh)

    lmbda = random.uniform(0.2, 0.8)
    # lmbda = 0.5
    print(f"start edge barycentric coordinate = {lmbda}")

    A = mesh.point(from_vh)
    B = mesh.point(to_vh)

    # Interpolate linearly: P = (1 - lambda) * p0 + lambda * p1
    P = (1.0 - lmbda) * np.array(A) + lmbda * np.array(B)

    theta = random.uniform( np.pi/6., +np.pi - np.pi/6.)
    # theta = np.pi / 3.
    print(f"start local angle = {theta}")

    return fh, heh, lmbda, theta, P


# Function to visualize the mesh with Polyscope
def visualize_mesh( mesh):
    # Prepare the data for visualization
    vertices = np.array([mesh.point(vh).tolist() for vh in mesh.vertices()] ) # array of vertex positions
    faces = np.array([[vh.idx() for vh in mesh.fv(face)] for face in mesh.faces()])  # array of face indices


    # Initialize Polyscope
    ps.init()
        
    # Register the mesh with Polyscope
    ps.register_surface_mesh("myMesh", vertices, faces)
    # ps.register_curve_network( "myGeodesic", np.array([P,P]), edges="line")


def main():
    """
    Main function to compute and visualize geodesic curves on a triangular mesh.

    This function reads a mesh file, initializes geodesic curves from random starting points,
    computes the curves by following the geodesic direction, and visualizes the results using Polyscope.

    Command-line Arguments:
        - sys.argv[1]: Path to the input mesh file (e.g., .obj file).
        - sys.argv[2]: Number of geodesic curves to compute.
        - sys.argv[3]: Length of each geodesic curve as a percentage of the mesh's diagonal length.
        - "-farthest": ensures that the farthest triangle from all triangles traversed by a geodesic is used each time a new line is started

    The function performs the following steps:
    1. Reads the input mesh file.
    2. Initializes Polyscope for visualization.
    3. For each geodesic curve:
        a. Initializes a starting point and direction on a random face.
        b. Computes the geodesic curve by iteratively finding the next point.
        c. Visualizes the computed geodesic curve.
    4. Visualizes the starting points of all geodesic curves.
    5. Displays the mesh and geodesic curves in the Polyscope viewer.

    Note: The function uses a fixed random seed (42) for reproducibility.
    """
    random.seed(42)
    # Read the mesh
    # mesh = om.read_trimesh("../data/planarGrid.obj")
    # mesh = om.read_trimesh("../data/cow.obj")
    # mesh = om.read_trimesh("../data/bunny.obj")
    mesh = om.read_trimesh( sys.argv[1])
    mesh_vertices = np.array(mesh.points())
    mesh_face_vertex_indices = np.array([[v.idx() for v in mesh.fv(fh)] for fh in mesh.faces()], dtype=int)
    # mesh = om.read_trimesh("../data/bunny.obj")

    diagonal = np.linalg.norm(np.max(mesh_vertices, axis=0) - np.min(mesh_vertices, axis=0))
    nCurve = int(sys.argv[2])
    lengthCurve = float(sys.argv[3]) * diagonal / 100 # lengthCurve in percentage of diagonal



    visualize_mesh( mesh)

    startingPoints = []
    facesWithPoints = set()

    for gi in range(nCurve):
        print(f"nCurve = {gi}")
        fh, heh, lmbda, theta, P = initGeodesic(mesh, mesh_vertices, mesh_face_vertex_indices, facesWithPoints)
        facesWithPoints.add(mesh.face_handle(heh).idx())
        polyLine = [P]
        startingPoints.append(P)
        currentLength = 0.
        while currentLength < lengthCurve:
        # for i in range(lengthCurve):
            heh, lmbda, theta, nP = findNextPoint( mesh, heh, lmbda, theta, polyLine[-1])
            facesWithPoints.add(mesh.face_handle(heh).idx())
            previousSegmentLength = np.linalg.norm( nP - polyLine[-1])
            currentLength += previousSegmentLength
            # theta += 25. * previousSegmentLength # petits cercles
            # theta += 10. * previousSegmentLength # petits cercles
            # theta += 3. * previousSegmentLength # petits cercles
            # theta += np.sin((5.*i)/lengthCurve*2.*np.pi) / 5. # sinusoides douces
            polyLine += [nP]

        ps.register_curve_network( f"myGeodesic_{gi}", np.array( polyLine), edges="line", radius=0.00275)

    # Show the mesh in the Polyscope viewer
    ps.register_point_cloud( f"startingPoints", np.array(startingPoints), radius=0.001)

    ps.show()

if __name__=="__main__":
    main()
